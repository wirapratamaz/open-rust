---
title: Module 2.4 - Improving Program Reliability
description: "Improving Program Reliability"
duration: 30 minutes
---

## Custom Error

- Functions may fail in more than one way
- Useful to communicate the failure reason
- Error enumeration
  - Enumerations allow errors to be easily defined
  - Can match on the enumeration to handle specific error conditions

---

## Error Requirements

- Implement the Debug trait
  - Displays error info in debug contexts
- Implement the Display trait
  - Displays error info in user contexts
- Implement the Error trait
  - Interop with code using dynamic errors

## Manual Error Creation

```rust
#[derive(Debug)]
enum LockError {
    MechanicalError(i32),
    NetworkError,
    NotAuthorized,
}

use std::error::Error;
impl Error for LockError {}
```

---

## Manual Error Creation

```rust
enum LockError {
    MechanicalError(i32),
    NetworkError,
    NotAuthorized,
}

use std::fmt;
impl fmt::Display for LockError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::MechanicalError(code) => write!(f, "Mechanical Error: {}", code),
            Self::NetworkError => write!(f, "Network Error"),
            Self::NotAuthorized => write!(f, "Not Authorized"),
        }
    }
}
```

---

## The ‘thiserror’ Crate

```rust
# Cargo.toml

[dependencies]
thiserror = "1.0"
```

---

## The ‘thiserror’ Crate

```rust
use thiserror::Error;

#[derive(Debug, Error)]
enum LockError {
    #[error("Mechanical Error: {0}")]
    MechanicalError(i32),
    #[error("Network Error")]
    NetworkError,
    #[error("Not Authorized")]
    NotAuthorized,
}
```

---

## Usage

```rust
fn lock_door() -> Result<(), LockError> {
    // ... some code ...
    Err(LockError::NetworkError)
}
```

---

## Error Conversion

```rust
use thiserror::Error;

#[derive(Debug, Error)]
enum NetworkError {
    #[error("Connection timed out")]
    TimeOut,
    #[error("Unreachable")]
    Unreachable,
}

#[derive(Debug, Error)]
enum LockError {
    #[error("Mechanical Error: {0}")]
    MechanicalError(i32, i32),
    #[error("Network Error")]
    NetworkError(#[from] NetworkError),
    #[error("Not Authorized")]
    NotAuthorized,
}
```

---

## Pro Tips: Do’s

- Prefer to use error enumerations over strings
  - More concisely communicates the problem
  - Can be used with match
  - Strings are OK when prototyping, or if the problem domain isn’t fully understood
    - Change to enumerations as soon as possible
- Keep errors specific
  - Limit error enumerations to:
    - Single modules
    - Single functions
- Try to use match as much as possible

---

## More Pro Tips: Don’ts

- Don’t put unrelated errors into a single enumeration
  - As the problem domain expands, the enumeration will become unwieldy
  - Changes to the enumeration will cascade across the entire codebase
  - Unclear which errors can be generated by a function

---

## Typestates

- Leverage type system to encode state changes
- Implemented by creating a type for each state
  - Use move semantics to invalidate a state
  - Return next state from previous state
  - Optionally drop the state
    - Close file, connection dropped, etc
  - Compile time enforcement of logic

---

## Example

```rust
struct BusTicket;
struct BoardedBusTicket;

impl BusTicket {
    fn board(self) -> BoardedBusTicket {
        BoardedBusTicket
    }
}

let ticket = BusTicket;
let boarded = ticket.board();

// Compile error
ticket.board();
```

---

## Example

```rust
struct File<'a>(&'a str);

impl<'a> File<'a> {
    fn read_bytes(&self) -> Vec<u8> {
        // ... read data ...
    }

    fn delete(self) {
        // ... delete file ...
    }
}

let file = File("data.txt");
let data = file.read_bytes();
file.delete();

// Compile error
let read_again = file.read_bytes();

```

---

---

## Arrays

- Contiguous memory region
- All elements have the same size
- Arrays are not dynamically sized
  - Size must be hard-coded
  - Usually prefer Vector
- Useful when writing algorithms with a fixed buffer size
  - Networking, crypto, matrices

---

## Syntax

```rust
let numbers = [1, 2, 3];
let numbers: [u8; 3] = [1, 2, 3];

fn func(arr: [u8; 3]) {}

fn func(arr: &[u8]) {}

fn func(arr: &mut [u8]) {}

```

---

## Slices

- A borrowed view into an array
- Can be iterated upon
- Optionally mutable
- Indices bounded by the slice size
  - Cannot go out of bounds of the initial slice
- Can create any number of subslices from an existing slice

---

## Slices – View Into An Array

TODO

---

## Slices & Vectors

- Borrowing a Vector as an argument to a function that requires a slice will automatically obtain a slice
- Always prefer to borrow a slice instead of a Vector

```rust
fn func(slice: &[u8]) {}

let numbers = vec![1, 2, 3];
func(&numbers);

let numbers: &[u8] = numbers.as_slice();
```

---

## Slicing With Ranges

```rust
let chars = vec!['A', 'B', 'C', 'D'];
let bc = &chars[1..=2];
let ab = &chars[0..2];
```
TODO

---

## Subslices

```rust
let chars = vec!['A', 'B', 'C', 'D'];
let bcd = &chars[1..=3];
let cd = &bcd[1..=2];
```
TODO 

---

## Use Case

- Read the first few bytes to determine header information
  - Take different actions based on the data using match
- Get the first or last elements of a slice
- No need for bounds checking on slices
  - Compiler ensures access are always within bounds

---

## Example

```rust
let chars = vec!['A', 'B', 'C', 'D'];
match chars.as_slice() {
    [first, .., last] => (),
    [single] => (),
    [] => (),
}

let chars = vec!['A', 'B', 'C', 'D'];
match chars.as_slice() {
    [one, two, ..] => (),
    [.., last] => (),
    [] => (),
}
```

---

## Overlapping Patterns

- Patterns easily overlap.
- Minimize number of match arms to avoid bugs

```rust
match slice {
    [first, ..] => (),
    [.., last] => (),
    [] => (),
}

```

Second arm always ignored

---

## Prevent Overlapping Patterns

- Match the largest patterns first, followed by smaller patterns

```rust
match slice {
    [] => (),
    [a, ..] => (),
    [a, b, ..] => (),
    [a, b, c, ..] => (),
    [a, b, c, d, ..] => (),
}
// "First two arms cover all cases, remaining will be ignored"
match slice {
    [a, b, c, d, ..] => (),
    [a, b, c, ..] => (),
    [a, b, ..] => (),
    [a, ..] => (),
    [] => (),
}
// "All arms can be matched"

```

---

## Guards

```rust
let nums = vec![7, 8, 9];
match nums.as_slice() {
    [first @ 1..=3, rest @ ..] => {
        // 'first' is always 1, 2 or 3
        // 'rest' is the remaining slice
    },
    [single] if single == &5 || single == &6 => (),
    [a, b] => (),
    [..] => (),
    [] => (),
}
```

---

## Type Aliases

- Give a new name to an existing type
  - Basic text substitution
- Simplifies complicated types
- Makes code easier to read & write
- Multiple aliases for the same type will work together, but maybe not as intended

---

## Syntax 

```rust
type Name = Type;
```

---

## Examples

```rust
type ContactName = String;
type Miles = u64;
type Centimeters = u64;

type Callbacks = HashMap<String, Box<Fn(i32, i32) -> i32>>;
```

---

## Usage

```rust
struct Contact {
    name: String,
    phone: String,
}

type ContactName = String;
type ContactIndex = HashMap<ContactName, Contact>;

fn add_contact(index: &mut ContactIndex, contact: Contact) {
    index.insert(contact.phone.to_owned(), contact);
}
```

---

## Generics/Lifetimes

```rust
type BorrowedItems<'a> = Vec<&'a str>;
type GenericThings<T> = Vec<Thing<T>>;
```
